{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"Installation/","text":"Installation The standard installation uses Helm 3 <https://helm.sh/docs/intro/install/> _ and the robusta-cli, but :ref: alternative methods <Additional Installation Methods> are described below. Configuring and installing Robusta takes 97.68 seconds on a 10 node cluster [#f1]_. You can also install on minikube or KIND. :ref: Uninstalling <Helm Uninstall> takes one command, so go ahead and try! Ask us on Slack or open a GitHub issue We will now configure Robusta in your cluster. For this we need to install Robusta, and also connect at least one destination (\"sink\"), and at least one source (\"triggers\"). .. image:: ./images/robusta_motion_graphics_transparent.gif :align: center Creating the config file To configure robusta, the Robusta CLI is required. Choose one of the installation methods below. Installation Methods Pip Docker pip install -U robusta-cli --no-cache Common Errors Python 3.7 or higher is required If you are using a system such as macOS that includes both Python 2 and Python 3, run pip3 instead of pip. Errors about tiller mean you are running Helm 2, not Helm 3 For Windows please use WSL Download robusta script and give it executable permissions: ```curl -fsSL -o robusta https://docs.robusta.dev/master/_static/robusta chmod +x robusta``` Use the script, for example: ./robusta version Common Errors Docker daemon is required. Generate a Robusta configuration. This will setup Slack and other integrations. We highly recommend enabling the cloud UI so you can see all features in action. If you\u2019d like to send Robusta messages to additional destinations (Discord, Telegram etc.). See Sink configuration <https://docs.robusta.dev/master/catalog/sinks/index.html> _. robusta gen-config Robusta on Minikube We don't recommend installing Robusta on Minikube because of a recent issue with minikube. More details here <https://github.com/kubernetes/minikube/issues/14806> _. Robusta not in PATH if you get \" command not found: robusta \", see :ref: Common errors <Common Errors> Save generated_values.yaml , somewhere safe. This is your Helm values.yaml file. Installing on multiple clusters Use the same generated_values.yaml for all your clusters (dev, prod, etc..). There's no need to run gen-config again. Standard Installation Add Robusta's chart repository: helm repo add robusta https://robusta-charts.storage.googleapis.com && helm repo update Specify your cluster's name and install Robusta using Helm. On some clusters this can take a while [#f2]_, so don't panic if it appears stuck: ???++ warning Test clusters (e.g Kind, MiniKube, Colima) Test clusters tend to have fewer resources. To lower the resource requests of Robusta, include ``--set isSmallCluster=true`` at the end of the install command. .. code-block:: bash :name: cb-helm-install-only-robusta helm install robusta robusta/robusta -f ./generated_values.yaml --set clusterName=<YOUR_CLUSTER_NAME> # --set isSmallCluster=true Verify the two Robusta pods and running with no errors in the logs: .. code-block:: bash :name: cb-get-pods-robusta-logs kubectl get pods -A | grep robusta robusta logs Seeing Robusta in action By default, Robusta sends notifications when Kubernetes pods crash. Create a crashing pod: .. code-block:: bash :name: cb-apply-crashpod kubectl apply -f https://gist.githubusercontent.com/robusta-lab/283609047306dc1f05cf59806ade30b6/raw Verify that the pod is actually crashing: .. code-block:: bash :name: cb-verify-crash-pod-crashing $ kubectl get pods -A NAME READY STATUS RESTARTS AGE crashpod-64d8fbfd-s2dvn 0/1 CrashLoopBackOff 1 7s Once the pod has reached two restarts, check your Slack channel for a message about the crashing pod. .. admonition:: Example Slack Message .. image:: /images/crash-report.png Open the Robusta UI <https://platform.robusta.dev/> _ (if you enabled it) and look for the same message there. Clean up the crashing pod: .. code-block:: bash :name: cb-delete-crashpod kubectl delete deployment crashpod Installing a second cluster When installing a second cluster on the same account, there's no need to run robusta gen-config again. Using your existing generated_values.yaml and the new clusterName run: .. code-block:: bash :name: cb-helm-install-only-robusta helm install robusta robusta/robusta -f ./generated_values.yaml --set clusterName=<YOUR_CLUSTER_NAME> # --set isSmallCluster=true .. admonition:: Where is my generated_values.yaml? If you have lost your ``generated_values.yaml`` file, you can extract it from any cluster running Robusta. In that case, ``clusterName`` and ``isSmallCluster`` may be already in ``generated_values.yaml``. Make sure to remove them before installing on the new cluster. .. code-block:: bash helm get values -o yaml robusta | grep -v clusterName: | grep -v isSmallCluster: > generated_values.yaml Next Steps Define your :ref: first automation <Automation Basics> Add your first :ref: Prometheus enrichment <Alert Enrichment> .. rubric:: Footnotes .. [#f1] See this great video on YouTube where a community member installs Robusta with a stopwatch. <https://www.youtube.com/watch?v=l_zaCaY_wls> _ If you beat his time by more than 30% and document it, we'll send you a Robusta mug too. .. [#f2] AWS EKS, we're looking at you! Additional Installation Methods Installing with GitOps Follow the instructions above to generate generated_values.yaml . Commit it to git and use ArgoCD or your favorite tool to install. Installing without the Robusta CLI Using the cli is totally optional. If you prefer, you can skip the CLI and fetch the default values.yaml : cb-helm-repo-add-show-values ```helm repo add robusta https://robusta-charts.storage.googleapis.com && helm repo update helm show values robusta/robusta``` Most values are documented in the :ref: Configuration Guide Do not use the values.yaml file in the GitHub repo. It has some empty placeholders which are replaced during our release process. Installing in a different namespace Create a namespace robusta and install robusta in the new namespace using: cb-helm-install-robusta-custom `helm install robusta robusta/robusta -f ./generated_values.yaml -n robusta --create-namespace` Verify that Robusta installed two deployments in the robusta namespace: `kubectl get pods -n robusta` Installing on OpenShift You will need to run one additional command: .. code-block:: bash :name: cb-oc-adm-policy-add oc adm policy add-scc-to-user anyuid -z robusta-runner-service-account It's possible to reduce the permissions more. Please feel free to open a PR suggesting something more minimal","title":"Installation"},{"location":"Installation/#_1","text":"The standard installation uses Helm 3 <https://helm.sh/docs/intro/install/> _ and the robusta-cli, but :ref: alternative methods <Additional Installation Methods> are described below. Configuring and installing Robusta takes 97.68 seconds on a 10 node cluster [#f1]_. You can also install on minikube or KIND. :ref: Uninstalling <Helm Uninstall> takes one command, so go ahead and try! Ask us on Slack or open a GitHub issue We will now configure Robusta in your cluster. For this we need to install Robusta, and also connect at least one destination (\"sink\"), and at least one source (\"triggers\"). .. image:: ./images/robusta_motion_graphics_transparent.gif :align: center Creating the config file To configure robusta, the Robusta CLI is required. Choose one of the installation methods below. Installation Methods Pip Docker pip install -U robusta-cli --no-cache Common Errors Python 3.7 or higher is required If you are using a system such as macOS that includes both Python 2 and Python 3, run pip3 instead of pip. Errors about tiller mean you are running Helm 2, not Helm 3 For Windows please use WSL Download robusta script and give it executable permissions: ```curl -fsSL -o robusta https://docs.robusta.dev/master/_static/robusta chmod +x robusta``` Use the script, for example: ./robusta version Common Errors Docker daemon is required. Generate a Robusta configuration. This will setup Slack and other integrations. We highly recommend enabling the cloud UI so you can see all features in action. If you\u2019d like to send Robusta messages to additional destinations (Discord, Telegram etc.). See Sink configuration <https://docs.robusta.dev/master/catalog/sinks/index.html> _. robusta gen-config Robusta on Minikube We don't recommend installing Robusta on Minikube because of a recent issue with minikube. More details here <https://github.com/kubernetes/minikube/issues/14806> _. Robusta not in PATH if you get \" command not found: robusta \", see :ref: Common errors <Common Errors> Save generated_values.yaml , somewhere safe. This is your Helm values.yaml file. Installing on multiple clusters Use the same generated_values.yaml for all your clusters (dev, prod, etc..). There's no need to run gen-config again.","title":""},{"location":"Installation/#standard-installation","text":"Add Robusta's chart repository: helm repo add robusta https://robusta-charts.storage.googleapis.com && helm repo update Specify your cluster's name and install Robusta using Helm. On some clusters this can take a while [#f2]_, so don't panic if it appears stuck: ???++ warning Test clusters (e.g Kind, MiniKube, Colima) Test clusters tend to have fewer resources. To lower the resource requests of Robusta, include ``--set isSmallCluster=true`` at the end of the install command. .. code-block:: bash :name: cb-helm-install-only-robusta helm install robusta robusta/robusta -f ./generated_values.yaml --set clusterName=<YOUR_CLUSTER_NAME> # --set isSmallCluster=true Verify the two Robusta pods and running with no errors in the logs: .. code-block:: bash :name: cb-get-pods-robusta-logs kubectl get pods -A | grep robusta robusta logs","title":"Standard Installation"},{"location":"Installation/#seeing-robusta-in-action","text":"By default, Robusta sends notifications when Kubernetes pods crash. Create a crashing pod: .. code-block:: bash :name: cb-apply-crashpod kubectl apply -f https://gist.githubusercontent.com/robusta-lab/283609047306dc1f05cf59806ade30b6/raw Verify that the pod is actually crashing: .. code-block:: bash :name: cb-verify-crash-pod-crashing $ kubectl get pods -A NAME READY STATUS RESTARTS AGE crashpod-64d8fbfd-s2dvn 0/1 CrashLoopBackOff 1 7s Once the pod has reached two restarts, check your Slack channel for a message about the crashing pod. .. admonition:: Example Slack Message .. image:: /images/crash-report.png Open the Robusta UI <https://platform.robusta.dev/> _ (if you enabled it) and look for the same message there. Clean up the crashing pod: .. code-block:: bash :name: cb-delete-crashpod kubectl delete deployment crashpod","title":"Seeing Robusta in action"},{"location":"Installation/#installing-a-second-cluster","text":"When installing a second cluster on the same account, there's no need to run robusta gen-config again. Using your existing generated_values.yaml and the new clusterName run: .. code-block:: bash :name: cb-helm-install-only-robusta helm install robusta robusta/robusta -f ./generated_values.yaml --set clusterName=<YOUR_CLUSTER_NAME> # --set isSmallCluster=true .. admonition:: Where is my generated_values.yaml? If you have lost your ``generated_values.yaml`` file, you can extract it from any cluster running Robusta. In that case, ``clusterName`` and ``isSmallCluster`` may be already in ``generated_values.yaml``. Make sure to remove them before installing on the new cluster. .. code-block:: bash helm get values -o yaml robusta | grep -v clusterName: | grep -v isSmallCluster: > generated_values.yaml","title":"Installing a second cluster"},{"location":"Installation/#next-steps","text":"Define your :ref: first automation <Automation Basics> Add your first :ref: Prometheus enrichment <Alert Enrichment> .. rubric:: Footnotes .. [#f1] See this great video on YouTube where a community member installs Robusta with a stopwatch. <https://www.youtube.com/watch?v=l_zaCaY_wls> _ If you beat his time by more than 30% and document it, we'll send you a Robusta mug too. .. [#f2] AWS EKS, we're looking at you!","title":"Next Steps"},{"location":"Installation/#additional-installation-methods","text":"Installing with GitOps Follow the instructions above to generate generated_values.yaml . Commit it to git and use ArgoCD or your favorite tool to install. Installing without the Robusta CLI Using the cli is totally optional. If you prefer, you can skip the CLI and fetch the default values.yaml : cb-helm-repo-add-show-values ```helm repo add robusta https://robusta-charts.storage.googleapis.com && helm repo update helm show values robusta/robusta``` Most values are documented in the :ref: Configuration Guide Do not use the values.yaml file in the GitHub repo. It has some empty placeholders which are replaced during our release process. Installing in a different namespace Create a namespace robusta and install robusta in the new namespace using: cb-helm-install-robusta-custom `helm install robusta robusta/robusta -f ./generated_values.yaml -n robusta --create-namespace` Verify that Robusta installed two deployments in the robusta namespace: `kubectl get pods -n robusta` Installing on OpenShift You will need to run one additional command: .. code-block:: bash :name: cb-oc-adm-policy-add oc adm policy add-scc-to-user anyuid -z robusta-runner-service-account It's possible to reduce the permissions more. Please feel free to open a PR suggesting something more minimal","title":"Additional Installation Methods"},{"location":"Overview/","text":"Welcome to Robusta Robusta is an open source platform for Kubernetes troubleshooting. It sits on top of your monitoring stack (Prometheus, Elasticsearch, etc.) and tells you why alerts occurred and how to fix them. Robusta has three main parts, all open source: An automations engine for Kubernetes Builtin automations to enrich and fix common alerts Manual troubleshooting tools for everything else There are additional optional components: An all-in-one bundle with Robusta, the Prometheus Operator, and default Kubernetes alerts A web UI to see all alerts, changes, and events in your cluster Example Use Cases Crashing Pod Event Correlation Remediate alerts Debug Pods Monitor crashing pods and send their logs to Slack Show application updates in Grafana to correlate them with error spikes Temporarily increase the HPA maximum so you can go back to sleep Attach the VSCode debugger to a running Python pod without tearing your hair out robusta playbooks trigger python_debugger name=podname namespace=default See :ref: Python debugger for more details /////Exact tabbing How it works Robusta automates everything that happens after you deploy your application. It is somewhat like Zapier/IFTTT for devops, with an emphasis on prebuilt automations and not just \"build your own\". For example, the following automation sends logs to Slack when an alert fires for crashing pods: triggers : - on_prometheus_alert : alert_name : KubePodCrashLooping actions : - logs_enricher : {} sinks : - slack Every automation has three parts: : Triggers When to run (on alerts, logs, changes, etc) : Actions What to do (over 50 builtin actions) : Sync Where to send the result (Slack, etc) Writing your own automations Many automations are included, but you can also write your own in Python. View example action (Python) # this runs on Prometheus alerts you specify in the YAML @action def my_enricher ( event : PrometheusKubernetesAlert ): # we have full access to the pod on which the alert fired pod = event . get_pod () pod_name = pod . metadata . name pod_logs = pod . get_logs () pod_processes = pod . exec ( \"ps aux\" ) # this is how you send data to slack or other destinations event . add_enrichment ([ MarkdownBlock ( \"*Oh no!* An alert occurred on \" + pod_name ), FileBlock ( \"crashing-pod.log\" , pod_logs ) ]) Next Steps :ref: Ready to install Robusta? Get started! <installation> Star us on GitHub to receive updates.","title":"Overview"},{"location":"Overview/#welcome-to-robusta","text":"Robusta is an open source platform for Kubernetes troubleshooting. It sits on top of your monitoring stack (Prometheus, Elasticsearch, etc.) and tells you why alerts occurred and how to fix them. Robusta has three main parts, all open source: An automations engine for Kubernetes Builtin automations to enrich and fix common alerts Manual troubleshooting tools for everything else There are additional optional components: An all-in-one bundle with Robusta, the Prometheus Operator, and default Kubernetes alerts A web UI to see all alerts, changes, and events in your cluster","title":"Welcome to Robusta"},{"location":"Overview/#example-use-cases","text":"Crashing Pod Event Correlation Remediate alerts Debug Pods Monitor crashing pods and send their logs to Slack Show application updates in Grafana to correlate them with error spikes Temporarily increase the HPA maximum so you can go back to sleep Attach the VSCode debugger to a running Python pod without tearing your hair out robusta playbooks trigger python_debugger name=podname namespace=default See :ref: Python debugger for more details /////Exact tabbing","title":"Example Use Cases"},{"location":"Overview/#how-it-works","text":"Robusta automates everything that happens after you deploy your application. It is somewhat like Zapier/IFTTT for devops, with an emphasis on prebuilt automations and not just \"build your own\". For example, the following automation sends logs to Slack when an alert fires for crashing pods: triggers : - on_prometheus_alert : alert_name : KubePodCrashLooping actions : - logs_enricher : {} sinks : - slack Every automation has three parts: : Triggers When to run (on alerts, logs, changes, etc) : Actions What to do (over 50 builtin actions) : Sync Where to send the result (Slack, etc)","title":"How it works"},{"location":"Overview/#writing-your-own-automations","text":"Many automations are included, but you can also write your own in Python. View example action (Python) # this runs on Prometheus alerts you specify in the YAML @action def my_enricher ( event : PrometheusKubernetesAlert ): # we have full access to the pod on which the alert fired pod = event . get_pod () pod_name = pod . metadata . name pod_logs = pod . get_logs () pod_processes = pod . exec ( \"ps aux\" ) # this is how you send data to slack or other destinations event . add_enrichment ([ MarkdownBlock ( \"*Oh no!* An alert occurred on \" + pod_name ), FileBlock ( \"crashing-pod.log\" , pod_logs ) ])","title":"Writing your own automations"},{"location":"Overview/#next-steps","text":":ref: Ready to install Robusta? Get started! <installation> Star us on GitHub to receive updates.","title":"Next Steps"},{"location":"Actions/Grafana/","text":"Grafana This page lists Robusta actions related to Grafana. Like all Robusta actions, these can be triggered by Prometheus/AlertManager, Kubernetes changes, :ref: and more <Triggers> . Prerequisites ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ You will need a Grafana API key with write permissions. Generating a Grafana API key. <https://stackoverflow.com/questions/63002202/options-for-creating-a-grafana-api-token> _ Builtin actions ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. robusta-action:: playbooks.robusta_playbooks.grafana_enrichment.add_deployment_lines_to_grafana on_deployment_update .. robusta-action:: playbooks.robusta_playbooks.grafana_enrichment.add_alert_lines_to_grafana .. robusta-action:: playbooks.robusta_playbooks.deployment_status_report.deployment_status_report on_deployment_update :reference-label: change_tracking__deployment_status_report","title":"Grafana"},{"location":"Actions/Grafana/#_1","text":"This page lists Robusta actions related to Grafana. Like all Robusta actions, these can be triggered by Prometheus/AlertManager, Kubernetes changes, :ref: and more <Triggers> . Prerequisites ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ You will need a Grafana API key with write permissions. Generating a Grafana API key. <https://stackoverflow.com/questions/63002202/options-for-creating-a-grafana-api-token> _ Builtin actions ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ .. robusta-action:: playbooks.robusta_playbooks.grafana_enrichment.add_deployment_lines_to_grafana on_deployment_update .. robusta-action:: playbooks.robusta_playbooks.grafana_enrichment.add_alert_lines_to_grafana .. robusta-action:: playbooks.robusta_playbooks.deployment_status_report.deployment_status_report on_deployment_update :reference-label: change_tracking__deployment_status_report","title":""},{"location":"Sink/DataDog/","text":"Robusta can send playbooks results to the Datadog events API. To configure datadog sink, we need a DataDog API key. The API key can be retrieved from your DataDog Account. Configuring the Datadog sink .. admonition:: values.yaml .. code-block:: yaml sinks_config: - datadog_sink: name: datadog_sink api_key: \"datadog api key\" Example Output: .. image:: /images/deployment-babysitter-datadog.png :width: 1000 :align: center","title":"Data Dog"},{"location":"Sink/DataDog/#configuring-the-datadog-sink","text":".. admonition:: values.yaml .. code-block:: yaml sinks_config: - datadog_sink: name: datadog_sink api_key: \"datadog api key\" Example Output: .. image:: /images/deployment-babysitter-datadog.png :width: 1000 :align: center","title":"Configuring the Datadog sink"},{"location":"Sink/Slack/","text":"Robusta can send playbook results to Slack. There are two ways to set this up. Recommended: Using Robusta's official Slack app When installing Robusta, run robusta gen-config and follow the prompts. This will use our official Slack app <https://slack.com/apps/A0214S5PHB4-robusta?tab=more_info> _. Robusta can only write messages. We don't require read permissions. You can also generate a key by running robusta integrations slack and setting the following Helm values: .. admonition:: values.yaml .. code-block:: yaml sinks_config: # slack integration params - slack_sink: name: main_slack_sink api_key: MY SLACK KEY slack_channel: MY SLACK CHANNEL This method is recommended as it supports multiple Kubernetes clusters and is easy to setup. Outgoing messages are sent directly to Slack. Incoming messages are routed through Robusta servers to the appropriate cluster. .. note:: You can change the slack_channel at any time in values.yaml. No need to re-run ``robusta integrations slack``. Not Recommended: Creating your own Slack app You can use Robusta with a custom Slack app as follows: Create a new Slack app. <https://api.slack.com/apps?new_app=1> _ Enable Socket mode in your Slack App and copy the websocket token into the Robusta deployment yaml. Under \"OAuth and Permissions\" add the following scopes: chat:write, files:write, incoming-webhook, and channels:history Under \"Event Subscriptions\" add bot user events for message.channels and press \"Save Changes\" Click \"Install into Workspace\" Copy the signing token from basic information and the bot token from \"OAuth and Permissions\". Add them to the yaml You will then need to run your own Slack relay or enable only outgoing messages. :ref: Contact us for details. <Community> Sending Robusta Notifications to a Private Channel First add Robusta to your workspace using one of the methods above. Then add the Robusta app to the private channel. See video below: .. raw:: html <div style=\"position: relative; padding-bottom: 62.5%; height: 0;\"><iframe src=\"https://www.loom.com/embed/a0b1a27a54df44fa95c483917b961b11\" frameborder=\"0\" webkitallowfullscreen mozallowfullscreen allowfullscreen style=\"position: absolute; top: 0; left: 0; width: 100%; height: 100%;\"></iframe></div>","title":"Slack"},{"location":"Sink/Slack/#recommended-using-robustas-official-slack-app","text":"When installing Robusta, run robusta gen-config and follow the prompts. This will use our official Slack app <https://slack.com/apps/A0214S5PHB4-robusta?tab=more_info> _. Robusta can only write messages. We don't require read permissions. You can also generate a key by running robusta integrations slack and setting the following Helm values: .. admonition:: values.yaml .. code-block:: yaml sinks_config: # slack integration params - slack_sink: name: main_slack_sink api_key: MY SLACK KEY slack_channel: MY SLACK CHANNEL This method is recommended as it supports multiple Kubernetes clusters and is easy to setup. Outgoing messages are sent directly to Slack. Incoming messages are routed through Robusta servers to the appropriate cluster. .. note:: You can change the slack_channel at any time in values.yaml. No need to re-run ``robusta integrations slack``.","title":"Recommended: Using Robusta's official Slack app"},{"location":"Sink/Slack/#not-recommended-creating-your-own-slack-app","text":"You can use Robusta with a custom Slack app as follows: Create a new Slack app. <https://api.slack.com/apps?new_app=1> _ Enable Socket mode in your Slack App and copy the websocket token into the Robusta deployment yaml. Under \"OAuth and Permissions\" add the following scopes: chat:write, files:write, incoming-webhook, and channels:history Under \"Event Subscriptions\" add bot user events for message.channels and press \"Save Changes\" Click \"Install into Workspace\" Copy the signing token from basic information and the bot token from \"OAuth and Permissions\". Add them to the yaml You will then need to run your own Slack relay or enable only outgoing messages. :ref: Contact us for details. <Community>","title":"Not Recommended: Creating your own Slack app"},{"location":"Sink/Slack/#sending-robusta-notifications-to-a-private-channel","text":"First add Robusta to your workspace using one of the methods above. Then add the Robusta app to the private channel. See video below: .. raw:: html <div style=\"position: relative; padding-bottom: 62.5%; height: 0;\"><iframe src=\"https://www.loom.com/embed/a0b1a27a54df44fa95c483917b961b11\" frameborder=\"0\" webkitallowfullscreen mozallowfullscreen allowfullscreen style=\"position: absolute; top: 0; left: 0; width: 100%; height: 100%;\"></iframe></div>","title":"Sending Robusta Notifications to a Private Channel"},{"location":"Sink/Telegram/","text":"Robusta can send playbook results to Telegram conversations. .. note:: Tables are sent as file attachments to Telegram sinks because it's too big for most Telegram chat clients. In addition, 2-way interactivity (``CallbackBlock``) isn't implemented yet. Get your Bot token Follow the instructions here <https://core.telegram.org/bots#6-botfather> _ to create a new Bot, and get your Bot token. Chat id Before using the sink, you must first start the conversation with your Bot. (Locate your Bot in your Telegram app, and start the conversation) If you want to send messages to a group, add the created Bot to your group (new or existing) and give the Bot the following group permissions: Send Messages , Send Media , Send Stickers and GIFs Next, we will need to obtain the chat id . Checkout this post <https://dev.to/rizkyrajitha/get-notifications-with-telegram-bot-537l#:~:text=keep%20the%20access%20token%20securely.%20Anyone%20with%20access%20token%20can%20manipulate%20your%20bot> _ to find out how. Configuring the Telegram sink Now we're ready to configure the Telegram sink. .. admonition:: values.yaml .. code-block:: yaml sinks_config: - telegram_sink: name: personal_telegram sink bot_token: <YOUR BOT TOKEN> chat_id: <CHAT ID> .. note:: If you don't want Robusta to send file attachments, set ``send_files`` to ``False`` under your Telegram sink. (True by default) You should now get playbooks results in Telegram!","title":"Telegram"},{"location":"Sink/Telegram/#get-your-bot-token","text":"Follow the instructions here <https://core.telegram.org/bots#6-botfather> _ to create a new Bot, and get your Bot token.","title":"Get your Bot token"},{"location":"Sink/Telegram/#chat-id","text":"Before using the sink, you must first start the conversation with your Bot. (Locate your Bot in your Telegram app, and start the conversation) If you want to send messages to a group, add the created Bot to your group (new or existing) and give the Bot the following group permissions: Send Messages , Send Media , Send Stickers and GIFs Next, we will need to obtain the chat id . Checkout this post <https://dev.to/rizkyrajitha/get-notifications-with-telegram-bot-537l#:~:text=keep%20the%20access%20token%20securely.%20Anyone%20with%20access%20token%20can%20manipulate%20your%20bot> _ to find out how.","title":"Chat id"},{"location":"Sink/Telegram/#configuring-the-telegram-sink","text":"Now we're ready to configure the Telegram sink. .. admonition:: values.yaml .. code-block:: yaml sinks_config: - telegram_sink: name: personal_telegram sink bot_token: <YOUR BOT TOKEN> chat_id: <CHAT ID> .. note:: If you don't want Robusta to send file attachments, set ``send_files`` to ``False`` under your Telegram sink. (True by default) You should now get playbooks results in Telegram!","title":"Configuring the Telegram sink"},{"location":"Triggers/Manual/","text":"Manual actions aren't just for troubleshooting. You can automate any repetitive task on Kubernetes: Motivation The main use-case for manual triggers is making troubleshooting easier. This ties into Robusta's goal of reducing MTTR (mean time to recovery). Additional use cases are discussed below. Troubleshooting examples A few examples: :ref: Debug Python pods in VSCode <Python debugger> :ref: Find memory leaks in applications <Python memory> :ref: Function-level CPU profiling <Python profiler> Other examples Manual actions aren't just for troubleshooting. You can automate any repetitive task on Kubernetes: Run chaos engineering scenarios <https://github.com/robusta-dev/robusta-chaos> _ Stress test pods over HTTP How it works Internally, troubleshooting actions are implemented the same way as other Robusta actions, like insights and automated fixes. A manual action is simply an action that can be triggered manually using the CLI. Many actions supports both manual and automated triggers. How to use manual triggers Use the Robusta CLI to manually trigger a supported action: .. code-block:: bash robusta playbooks trigger <action_name> name=<name> namespace=<namespace> kind=<kind> <key>=<value> The parameters above are: name The name of a Kubernetes resource namespace The resource's namespace kind pod , deployment , or any other resource the action supports. This can be left out for playbooks that support one input type.","title":"Manual"},{"location":"Triggers/Manual/#motivation","text":"The main use-case for manual triggers is making troubleshooting easier. This ties into Robusta's goal of reducing MTTR (mean time to recovery). Additional use cases are discussed below.","title":"Motivation"},{"location":"Triggers/Manual/#troubleshooting-examples","text":"A few examples: :ref: Debug Python pods in VSCode <Python debugger> :ref: Find memory leaks in applications <Python memory> :ref: Function-level CPU profiling <Python profiler>","title":"Troubleshooting examples"},{"location":"Triggers/Manual/#other-examples","text":"Manual actions aren't just for troubleshooting. You can automate any repetitive task on Kubernetes: Run chaos engineering scenarios <https://github.com/robusta-dev/robusta-chaos> _ Stress test pods over HTTP","title":"Other examples"},{"location":"Triggers/Manual/#how-it-works","text":"Internally, troubleshooting actions are implemented the same way as other Robusta actions, like insights and automated fixes. A manual action is simply an action that can be triggered manually using the CLI. Many actions supports both manual and automated triggers.","title":"How it works"},{"location":"Triggers/Manual/#how-to-use-manual-triggers","text":"Use the Robusta CLI to manually trigger a supported action: .. code-block:: bash robusta playbooks trigger <action_name> name=<name> namespace=<namespace> kind=<kind> <key>=<value> The parameters above are: name The name of a Kubernetes resource namespace The resource's namespace kind pod , deployment , or any other resource the action supports. This can be left out for playbooks that support one input type.","title":"How to use manual triggers"},{"location":"Triggers/SmartTriggers/","text":"These high-level triggers identify interesting events in your cluster. .. _smart_triggers: These high-level triggers identify interesting events in your cluster. | Under the hood, smart triggers are implemented on top of lower-level triggers. | For example, the on_pod_crash_loop trigger internally listens to other :ref: Kubernetes (API Server) triggers and applies logic to fire only on crashing pods. Example triggers Pod Crash Loop ^^^^^^^^^^^^^^^^^^^ .. _on_pod_crash_loop: on_pod_crash_loop This trigger will fire when a Pod is crash looping. .. code-block:: yaml customPlaybooks: - triggers: - on_pod_crash_loop: restart_reason: \"CrashLoopBackOff\" actions: - report_crash_loop: {} Trigger parameters: restart_reason : Limit restart loops for this specific reason. If omitted, all restart reasons will be included. restart_count : Fire only after the specified number of restarts rate_limit : Limit firing to once every rate_limit seconds Pod OOMKilled ^^^^^^^^^^^^^^^^^^^ .. _on_pod_oom_killed: on_pod_oom_killed This trigger will fire when a Pod is OOMKilled. .. code-block:: yaml customPlaybooks: - triggers: - on_pod_oom_killed: rate_limit: 900 exclude: - name: \"oomkilled-pod\" namespace: \"default\" actions: - pod_graph_enricher: resource_type: Memory display_limits: true Trigger parameters: rate_limit : Limit firing to once every rate_limit seconds exclude : A list of pod name prefixes and/or namespaces that this trigger will ignore. All pods that start with name in namespace namespace will be ignored for this trigger. If A name is defined without a namespace than all pods with that name prefix will be ignored for this trigger. If A namespace is defined without a name than all pods in that namespace will be ignored for this trigger. Container OOMKilled ^^^^^^^^^^^^^^^^^^^ .. _on_container_oom_killed: on_container_oom_killed This trigger will fire when a Container is OOMKilled. .. code-block:: yaml customPlaybooks: - triggers: - on_container_oom_killed: rate_limit: 900 exclude: - name: \"oomkilled-container\" namespace: \"default\" actions: - oomkilled_container_graph_enricher: resource_type: Memory Trigger parameters: rate_limit : Limit firing to once every rate_limit seconds exclude : A list of container name prefixes and/or namespaces that this trigger will ignore. All containers that start with name in namespace namespace will be ignored for this trigger. If A name is defined without a namespace than all containers with that name prefix will be ignored for this trigger. If A namespace is defined without a name than all containers in that namespace will be ignored for this trigger. Job Failure ^^^^^^^^^^^^^^^^^^^ .. _on_job_failure: on_job_failure This trigger will fire when the Job status is updated to \"failed\". .. code-block:: yaml customPlaybooks: - triggers: - on_job_failure: namespace_prefix: robusta actions: - create_finding: title: \"Job $name on namespace $namespace failed\" aggregation_key: \"Job Failure\" - job_events_enricher: { } .. note:: Have an idea for another smart trigger? Please open a github `issue <https://github.com/robusta-dev/robusta/issues/new?assignees=&labels=&template=other.md&title=>`_","title":"Smart Trigger"},{"location":"Triggers/SmartTriggers/#_1","text":".. _smart_triggers: These high-level triggers identify interesting events in your cluster. | Under the hood, smart triggers are implemented on top of lower-level triggers. | For example, the on_pod_crash_loop trigger internally listens to other :ref: Kubernetes (API Server) triggers and applies logic to fire only on crashing pods.","title":""},{"location":"Triggers/SmartTriggers/#example-triggers","text":"Pod Crash Loop ^^^^^^^^^^^^^^^^^^^ .. _on_pod_crash_loop: on_pod_crash_loop This trigger will fire when a Pod is crash looping. .. code-block:: yaml customPlaybooks: - triggers: - on_pod_crash_loop: restart_reason: \"CrashLoopBackOff\" actions: - report_crash_loop: {} Trigger parameters: restart_reason : Limit restart loops for this specific reason. If omitted, all restart reasons will be included. restart_count : Fire only after the specified number of restarts rate_limit : Limit firing to once every rate_limit seconds Pod OOMKilled ^^^^^^^^^^^^^^^^^^^ .. _on_pod_oom_killed: on_pod_oom_killed This trigger will fire when a Pod is OOMKilled. .. code-block:: yaml customPlaybooks: - triggers: - on_pod_oom_killed: rate_limit: 900 exclude: - name: \"oomkilled-pod\" namespace: \"default\" actions: - pod_graph_enricher: resource_type: Memory display_limits: true Trigger parameters: rate_limit : Limit firing to once every rate_limit seconds exclude : A list of pod name prefixes and/or namespaces that this trigger will ignore. All pods that start with name in namespace namespace will be ignored for this trigger. If A name is defined without a namespace than all pods with that name prefix will be ignored for this trigger. If A namespace is defined without a name than all pods in that namespace will be ignored for this trigger. Container OOMKilled ^^^^^^^^^^^^^^^^^^^ .. _on_container_oom_killed: on_container_oom_killed This trigger will fire when a Container is OOMKilled. .. code-block:: yaml customPlaybooks: - triggers: - on_container_oom_killed: rate_limit: 900 exclude: - name: \"oomkilled-container\" namespace: \"default\" actions: - oomkilled_container_graph_enricher: resource_type: Memory Trigger parameters: rate_limit : Limit firing to once every rate_limit seconds exclude : A list of container name prefixes and/or namespaces that this trigger will ignore. All containers that start with name in namespace namespace will be ignored for this trigger. If A name is defined without a namespace than all containers with that name prefix will be ignored for this trigger. If A namespace is defined without a name than all containers in that namespace will be ignored for this trigger. Job Failure ^^^^^^^^^^^^^^^^^^^ .. _on_job_failure: on_job_failure This trigger will fire when the Job status is updated to \"failed\". .. code-block:: yaml customPlaybooks: - triggers: - on_job_failure: namespace_prefix: robusta actions: - create_finding: title: \"Job $name on namespace $namespace failed\" aggregation_key: \"Job Failure\" - job_events_enricher: { } .. note:: Have an idea for another smart trigger? Please open a github `issue <https://github.com/robusta-dev/robusta/issues/new?assignees=&labels=&template=other.md&title=>`_","title":"Example triggers"}]}